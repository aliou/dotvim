" @sjl / @stevelosh's Focus {{{

" "Focus" the current line.  Basically:
"
" 1. Close all folds.
" 2. Open just the folds containing the current line.
" 3. Move the line to a little bit (15 lines) above the center of the screen.
" 4. Pulse the cursor line.  My eyes are bad.

function! s:Pulse() " {{{
  redir => old_hi
  silent execute 'hi CursorLine'
  redir END
  let old_hi = split(old_hi, '\n')[0]
  let old_hi = substitute(old_hi, 'xxx', '', '')

  let steps = 8
  let width = 1
  let start = width
  let end = steps * width
  let color = 233

  for i in range(start, end, width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor
  for i in range(end, start, -1 * width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor

  execute 'hi ' . old_hi
endfunction " }}}
command! -nargs=0 Pulse call s:Pulse()
nnoremap <c-e> mzzMzvzz15<c-e>`z:Pulse<cr>

" }}}

" Toggle the text width and the color column.
function! s:ToggleWidth() " {{{
  if &l:textwidth >= 80
    set tw=0 cc=0
  else
    set tw=80 cc=+1
  endif
endfunction " }}}
command! -nargs=0 ToggleWidth call s:ToggleWidth()

" nnoremap <Leader>w :ToggleWidth<CR>

" Visual search. Stolen from @sjl.
function! s:VSetSearch() " {{{
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfunction " }}}

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>


" Breathe {{{
" Give more room to the current line.
"
" TODO: Visual mode.
function! s:Breathe() " {{{
  call append('.', '')
  call append(line('.') - 1, '')
endfunction " }}}
" }}}
command! -nargs=0 Breathe call s:Breathe()
nnoremap <c-b> :Breathe<cr>

" Wipeout: Remove hidden buffers {{{
function! s:Wipeout()
  " list of *all* buffer numbers
  let l:buffers = range(1, bufnr('$'))

  " what tab page are we in?
  let l:currentTab = tabpagenr()
  try
    " go through all tab pages
    let l:tab = 0
    while l:tab < tabpagenr('$')
      let l:tab += 1

      " go through all windows
      let l:win = 0
      while l:win < winnr('$')
        let l:win += 1
        " whatever buffer is in this window in this tab, remove it from
        " l:buffers list
        let l:thisbuf = winbufnr(l:win)
        call remove(l:buffers, index(l:buffers, l:thisbuf))
      endwhile
    endwhile

    " if there are any buffers left, delete them
    if len(l:buffers)
      execute 'bwipeout' join(l:buffers)
    endif
  finally
    " go back to our original tab page
    execute 'tabnext' l:currentTab
  endtry
endfunction
" }}}
command! -nargs=0 Wipeout call s:Wipeout()

" Gtask: Run gulp tasks through dispatch. {{{

" Gulp function.
"
" Locally sets the make program to gulp <task>.
" TODO: Set the errorformat string so the quickfix only opens on error.
function! s:GulpTask(task)
  let &l:makeprg     = "gulp " . a:task
  let &l:errorformat = ""
  Make
endfunction

" GulpTask completion function.
"
" Gets all the tasks by opening the gulpfile and getting all the lines defining
" a task.
"
" Since we are using `-complete` instead of `-completelist`, we must return a
" string, with the different terms separated by '\n'.
"
" TODO: Use `-completelist` (Meaning filtering the terms by the first argument
" of the function. But "ain't nobody got time for that").
function! s:ListTasks(A, L, P)
  let tasks = []
  let regex = '\v("([^"]*)"|''([^'']*)'')'

  for line in readfile("gulpfile.js")
    if line =~ "gulp.task"
      let task = substitute(matchstr(line, regex), '\v("|'')', "", "g")
      call add(tasks, task)
    endif
  endfor

  return join(sort(tasks), "\n")
endfunction

" }}}
" Only define The `GulpTask` and `GTask` commands if the gulpfile exists.
if filereadable("gulpfile.js")
  command! -complete=custom,s:ListTasks -nargs=1 GulpTask :call s:GulpTask(<f-args>)
  command! -complete=custom,s:ListTasks -nargs=1 GTask :call s:GulpTask(<f-args>)
endif

" vim:ft=vim
